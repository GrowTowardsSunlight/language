### 列表的表达

[data1,data2,...datan]

- 列表是有序表，支持元素的增删改查，能通过位置序号访问其中元素。

- 支持多种数据类型，元素可以是字符串，数字类型，布尔类型，列表，元组，字典等等。

- 使用for循环对列表进行遍历。

构造列表
```python
#方法1
ls = ["test",5,True,{"version":3.7}]
#方法2
list(iterable)  #把可迭代对象里的每个字符作为列表里的元素。
#可迭代对象包括字符串、元组、集合、range()等
#字符串转列表
list("薄雾浓云愁永昼 瑞脑消金兽")
['薄', '雾', '浓', '云', '愁', '永', '昼', ' ', '瑞', '脑', '消', '金', '兽']
#元组转列表
list(('我','们','不','一','样'))
['我', '们', '不', '一', '样']
#集合转列表
list({'朱雀','玄武','python'})
['python', '朱雀', '玄武']
#range(起始数字,终止数字,数字间隔) 范围不包含终止数字。起始数字默认为0，数字间隔默认为1，终止数字不能缺省。
list(range(1,11,2))
[1, 3, 5, 7, 9]
```
### 列表的索引和切片

- 列表的索引

正向索引从0开始递增，反向索引从-1开始递减。
```python
ls = ["test",5,True,{"version":3.7.6}]
print(ls[0],ls[-1])
test {'version': 3.7}
```
- 列表的切片

格式：变量名[开始位置:结束位置:切片间隔]

切片范围不包含结束位置。

切片间隔k表示每隔K-1个元素取一个元素。

切片间隔默认为1，即如果不写，为正向切片且间隔为1

正向切片：切片间隔为正，按位置从小到大取元素。

    开始位置默认为第一个元素的位置(0或-len)，如不写结束位置默认为包括最后一个元素。

    切片间隔k表示取的下一个数的位置比上一个数大k。

    开始位置必须小于结束位置，否则切片为空字符串。

反向切片：切片间隔为负，按位置从大到小取元素。

    开始位置默认为最后一个元素(-1或len-1)，如不写结束位置默认为包括第一个元素，切片间隔必须为负。

    切片间隔k表示取的下一个数的位置比上一个数小k。

    开始位置必须大于结束位置，否则切片为空字符串。

[注]正向切片可以用反向索引，反向切片也可以用正向索引，正向索引和反向索引也可以同时使用。

与[字符串和元组索引和切片](https://github.com/zyxhzsh/artificial-intelligence/blob/master/人工智能python基础/markdown/第二章%20基本数据类型/字符串类型.md)相同。

### 列表的操作符
```python
#列表的拼接：list1 + list2 #不常用
a,b = [1,2],[3,4]
a+b
[1, 2, 3, 4]
#成倍复制：n*list或者list*n 成倍复制是初始化列表的一种方法。
[0]*10
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

### 列表的操作函数

- 插入元素
```python
列表.append(待增元素)         #在表尾插入元素
ls1 = ['a','b','c']
ls1.append(1)
列表.insert(位置编号,待增元素)  #在任意位置插入元素
ls1 = ['a','b','c']
ls1.insert(1,[1,2])
#在表尾将另一个表作为一个元素插入 ls1.append(ls2) 
ls1 = ['a','b','c']
ls2 = ['d','e']
ls1.append(ls2)             #把表ls2作为一个元素插入到表ls1表尾
ls1
['a', 'b', 'c', ['d', 'e']]
```
- 合并列表
```python
ls1 = ['a','b','c']
ls2 = ['d','e']
ls1.extend(ls2)  #把表ls2中的元素按顺序插入到表ls1表尾
ls1
['a', 'b', 'c', 'd', 'e']
```
- 删除元素
```python
列表.pop(删除元素的位置)  #默认为最后一个元素，返回被删除元素，可以用变量接收。
ls2 = ['d','e','f']
ls2.pop(1)
ls2
['d', 'f']
列表.remove(待删元素)    #删除列表中第一次出现的待删元素
ls1 = ['a', 'b', 'c', 'd', 'e','c','c']
ls1.remove('c')
ls1
['a', 'b', 'd', 'e', 'c', 'c']
#删除列表中的特定值
ls1 = ['a', 'b', 'c', 'd', 'e','c','c']
while 'c' in ls1:
	ls1.remove('c')
ls1
['a', 'b', 'd', 'e']
```
- 查找元素
```python
列表.index('待查元素')  #返回待查元素的位置,若不存在该元素会报错
ls2 = ['d','e','f']
print(ls2.index('e'))
1
```
- 修改元素

列表[待修改元素的位置] = 新值
```python
ls2 = ['d','e','f']
ls2[2]='a'
ls2
['d', 'e', 'a']
```
- 列表的复制
```python
#错误的方法
ls1 = ['d','e','f']
ls2 = ls1  只是起了别名，两个变量是同一个列表，对一个进行修改另一个也会被修改。
#浅拷贝(列表的元素都是不可变类型时可用浅拷贝，若可变浅拷贝会出错)
ls2 = ls1.copy() 或 ls2=ls1[:]或ls2=list(ls1)
```
- 列表的排序
```python
#永久排序
ls1.sort(reverse= False)  #递增排序，默认为递增
ls1.sort(reverse= True)  #递减排序
#临时排序，原列表不变,返回排序后的列表
ls2 = sorted(ls1,reverse = False/True)  #默认为递增
```

- 列表的翻转
```python
#永久翻转
ls1.reverse()
#临时翻转
ls1[::-1]  #返回翻转后的列表，可以用ls2保存翻转后的列表
```
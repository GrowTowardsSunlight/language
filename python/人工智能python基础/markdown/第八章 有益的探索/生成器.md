【引例】生成从1到100万，这些数字各自的平方。

可以用列表推导，把这个100w个元素存在一个列表里。但这样会占用内存里大量的空间。

当我们要使用列表里的数字时，比如下面这个货循环，每次用到的都是一个数字，不需要同时用很多数字。因此，这种方法比较浪费空间。
```python
ls = [i**2 for i in range(1,1000001)]
for i in ls:
    pass
```

每次只需要一个数字，但是又不得不用一个非常大的空间来把这些数字存储起来。于是生成器就应运而生了，它就是来解决这个问题。

## 生成器

采用惰性计算的方式，一边执行一边计算，只计算每次需要的值。因此无需一次性存储海量的数据。

实际上一直在执行next()操作，取到一个值，直到生成器里没有元素可取了为止。

生成器既能满足我们的需求，又避免了存储海量数据所占用的大量内存。

可以用生成器表达式或者生成器函数构造生成器

### 生成器表达式

- 海量数据，不需存储
```python
squares = (i**2 for i in range(1000000))
for i in squares:
    pass
```
- 求0-100的和

无需一次存储全部数据，节约内存。
```python
sum(i for i in range(101))
```
### 生成器函数yield

- 生成斐波那契数列

数列的前两个元素为1,1,之后的元素为其前两个元素之和。
```python
#未使用生成器函数
def fib(max):
    ls = []
    n, a, b = 0, 1, 1  #n为计数器，a,b为前两个元素
    while  n < max:
        ls.append(a)
        a, b =b, a + b
        n = n + 1
    return ls

fib(10)

若每次只需要用到其中一个就可以了,不需要显式存储，只要能打印出来，可以改为

def fib(max):
    ls = []
    n, a, b = 0, 1, 1  #n为计数器，a,b为前两个元素
    while  n < max:
        print(a)
        a, b =b, a + b
        n = n + 1

fib(10)

若还要进行一些相应的操作，就需要构造生成器函数。

def fib(max):
    ls = []
    n, a, b = 0, 1, 1  #n为计数器，a,b为前两个元素
    while  n < max:
        yield a         
        a, b =b, a + b
        n = n + 1

fib(10)
```

首先函数会顺序执行，当执行到yield的时候就会停止，把yield后面的元素进行返回。然后它就停在这里，直到再执行下一次的next()操作，它会从停止的地方再接着往下进行，然后进行下一次while循环。如果条件成立，接着进入到下一个yield。如此反复，直到while循环结束。
```
<generator object fib at 0x107fce3d0>
```
遍历生成器
```python
for i in fib(10):
    print(i) #可以对每一个数字进行相应的操作
```
```
1
1
2
3
5
8
13
21
34
55
```